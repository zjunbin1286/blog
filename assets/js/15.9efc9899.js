(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{639:function(v,_,e){"use strict";e.r(_);var t=e(11),o=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"_1-vue2-0组件通信方式有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue2-0组件通信方式有哪些"}},[v._v("#")]),v._v(" 1. vue2.0组件通信⽅式有哪些？")]),v._v(" "),e("hr"),v._v(" "),e("ul",[e("li",[e("p",[v._v("⽗⼦组件通信：\n"),e("code",[v._v("props")]),v._v(" 和 "),e("code",[v._v("event")]),v._v("、"),e("code",[v._v("v-model")]),v._v("、 "),e("code",[v._v(".sync")]),v._v("、 "),e("code",[v._v("ref")]),v._v("、 "),e("code",[v._v("$parent")]),v._v(" 和 "),e("code",[v._v("$children")])])]),v._v(" "),e("li",[e("p",[v._v("非⽗⼦组件通信：\n"),e("code",[v._v("$attr")]),v._v(" 和 "),e("code",[v._v("$listeners")]),v._v("、 "),e("code",[v._v("provide")]),v._v(" 和 "),e("code",[v._v("inject")]),v._v("、"),e("code",[v._v("eventbus")]),v._v("、通过根实例"),e("code",[v._v("$root")]),v._v("访问、\n"),e("code",[v._v("vuex")]),v._v("、"),e("code",[v._v("dispatch")]),v._v(" 和 "),e("code",[v._v("brodcast")])])])]),v._v(" "),e("h2",{attrs:{id:"_2-v-model是如何实现双向绑定的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-v-model是如何实现双向绑定的"}},[v._v("#")]),v._v(" 2. v-model是如何实现双向绑定的？")]),v._v(" "),e("hr"),v._v(" "),e("ul",[e("li",[e("p",[v._v("vue 2.0\n"),e("code",[v._v("v-model")]),v._v(" 是⽤来在表单控件或者组件上创建双向绑定的，他的本质是 "),e("code",[v._v("v-bind")]),v._v(" 和 "),e("code",[v._v("v-on")]),v._v(" 的语法糖，在\n⼀个组件上使⽤ "),e("code",[v._v("v-model")]),v._v(" ，默认会为组件绑定名为 "),e("code",[v._v("value")]),v._v(" 的 "),e("code",[v._v("prop")]),v._v(" 和名为 "),e("code",[v._v("input")]),v._v(" 的事件。")])]),v._v(" "),e("li",[e("p",[v._v("Vue3.0\n在 3.x 中，⾃定义组件上的 "),e("code",[v._v("v-model")]),v._v(" 相当于传递了 "),e("code",[v._v("modelValue prop")]),v._v(" 并接收抛出的\n"),e("code",[v._v("update:modelValue")]),v._v(" 事件")])])]),v._v(" "),e("h2",{attrs:{id:"_3-vuex和单纯的全局对象有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-vuex和单纯的全局对象有什么区别"}},[v._v("#")]),v._v(" 3. Vuex和单纯的全局对象有什么区别？")]),v._v(" "),e("hr"),v._v(" "),e("p",[e("strong",[v._v("Vuex和全局对象主要有两⼤区别：")])]),v._v(" "),e("ol",[e("li",[v._v("Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发⽣变\n化，那么相应的组件也会相应地得到⾼效更新。")]),v._v(" "),e("li",[v._v("不能直接改变 store 中的状态。改变 store 中的状态的唯⼀途径就是显式地提交 (commit)mutation。这样使得我们可以⽅便地跟踪每⼀个状态的变化，从⽽让我们能够实现⼀些⼯具帮助我们更好地了解我们的应⽤。")])]),v._v(" "),e("h2",{attrs:{id:"_4-vue-的父组件和子组件生命周期钩子执行顺序是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-的父组件和子组件生命周期钩子执行顺序是什么"}},[v._v("#")]),v._v(" 4. Vue 的⽗组件和⼦组件⽣命周期钩⼦执⾏顺序是什么？")]),v._v(" "),e("hr"),v._v(" "),e("p",[e("strong",[v._v("渲染过程：")]),v._v("\n⽗组件挂载完成⼀定是等⼦组件都挂载完成后，才算是⽗组件挂载完，所以⽗组件的mounted在⼦组件mouted之后")]),v._v(" "),e("p",[v._v("⽗beforeCreate -> ⽗created -> ⽗beforeMount -> ⼦beforeCreate -> ⼦created -> ⼦beforeMount\n-> ⼦mounted -> ⽗mounted")]),v._v(" "),e("p",[e("strong",[v._v("⼦组件更新过程：")])]),v._v(" "),e("ol",[e("li",[v._v("影响到⽗组件： ⽗beforeUpdate -> ⼦beforeUpdate->⼦updated -> ⽗updted")]),v._v(" "),e("li",[v._v("不影响⽗组件： ⼦beforeUpdate -> ⼦updated")])]),v._v(" "),e("p",[e("strong",[v._v("⽗组件更新过程：")])]),v._v(" "),e("ol",[e("li",[v._v("影响到⼦组件： ⽗beforeUpdate -> ⼦beforeUpdate->⼦updated -> ⽗updted")]),v._v(" "),e("li",[v._v("不影响⼦组件： ⽗beforeUpdate -> ⽗updated")])]),v._v(" "),e("p",[e("strong",[v._v("销毁过程：")]),v._v("\n⽗beforeDestroy -> ⼦beforeDestroy -> ⼦destroyed -> ⽗destroyed")]),v._v(" "),e("p",[v._v("看起来很多好像很难记忆，其实只要理解了，不管是哪种情况，都⼀定是⽗组件等待⼦组件完成后，才会执⾏⾃⼰对应完成的钩⼦，就可以很容易记住")]),v._v(" "),e("h2",{attrs:{id:"_5-v-show-和-v-if-有哪些区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-v-show-和-v-if-有哪些区别"}},[v._v("#")]),v._v(" 5. v-show 和 v-if 有哪些区别？")]),v._v(" "),e("hr"),v._v(" "),e("ul",[e("li",[e("p",[e("code",[v._v("v-if")]),v._v(" 会在切换过程中对条件块的事件监听器和⼦组件进⾏"),e("strong",[v._v("销毁和重建")]),v._v("，如果初始条件是false，则什么都不做，直到条件第⼀次为true时才开始渲染模块。")])]),v._v(" "),e("li",[e("p",[e("code",[v._v("v-show")]),v._v(" 只是"),e("strong",[v._v("基于css进⾏切换")]),v._v("，不管初始条件是什么，都会渲染。")])])]),v._v(" "),e("p",[v._v("所以， "),e("code",[v._v("v-if")]),v._v(" 切换的开销更⼤，⽽ "),e("code",[v._v("v-show")]),v._v(" 初始化渲染开销更⼤，"),e("strong",[v._v("在需要频繁切换，或者切换的部分dom很复杂时，使⽤ "),e("code",[v._v("v-show")]),v._v(" 更合适。渲染后很少切换的则使⽤ "),e("code",[v._v("v-if")]),v._v(" 更合适。")])]),v._v(" "),e("h2",{attrs:{id:"_6-vue-中-v-html-会导致什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-中-v-html-会导致什么问题"}},[v._v("#")]),v._v(" 6. Vue 中 v-html 会导致什么问题")]),v._v(" "),e("p",[v._v("在⽹站上动态渲染任意 HTML，"),e("strong",[v._v("很容易导致 XSS 攻击")]),v._v("。所以只能在可信内容上使⽤ v-html，且永远不能⽤于⽤户提交的内容上。")]),v._v(" "),e("h2",{attrs:{id:"_7-v-for-中-key-的作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-v-for-中-key-的作用是什么"}},[v._v("#")]),v._v(" 7. v-for 中 key 的作⽤是什么？")]),v._v(" "),e("hr"),v._v(" "),e("p",[e("code",[v._v("key")]),v._v(" 是给每个 "),e("code",[v._v("vnode")]),v._v(" 指定的唯⼀ "),e("code",[v._v("id")]),v._v(" ，在同级的 "),e("code",[v._v("vnode")]),v._v(" diff 过程中，可以根据 "),e("code",[v._v("key")]),v._v(" 快速的对⽐，来判断是否为相同节点，并且利⽤ "),e("code",[v._v("key")]),v._v(" 的唯⼀性可以⽣成 "),e("code",[v._v("map")]),v._v(" 来更快的获取相应的节点。")]),v._v(" "),e("p",[v._v("另外指定 "),e("code",[v._v("key")]),v._v(" 后，就不再采⽤“就地复⽤”策略了，可以保证渲染的准确性。")]),v._v(" "),e("h2",{attrs:{id:"_8-为什么-v-for-和-v-if-不建议用在一起"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-为什么-v-for-和-v-if-不建议用在一起"}},[v._v("#")]),v._v(" 8. 为什么 v-for 和 v-if 不建议⽤在⼀起")]),v._v(" "),e("hr"),v._v(" "),e("ul",[e("li",[v._v("当 "),e("code",[v._v("v-for")]),v._v(" 和 "),e("code",[v._v("v-if")]),v._v(" 处于同⼀个节点时，"),e("code",[v._v("v-for")]),v._v(" 的优先级⽐ "),e("code",[v._v("v-if")]),v._v(" 更⾼，这意味着 "),e("code",[v._v("v-if")]),v._v(" 将分别重复运⾏于每个 "),e("code",[v._v("v-for")]),v._v(" 循环中。如果要遍历的数组很⼤，⽽真正要展示的数据很少时，这将造成很⼤的性能浪费。")]),v._v(" "),e("li",[v._v("这种场景建议使⽤ "),e("code",[v._v("computed")]),v._v(" ，先对数据进⾏过滤。")])]),v._v(" "),e("h2",{attrs:{id:"_9-vue-router-hash-模式和-history-模式有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-router-hash-模式和-history-模式有什么区别"}},[v._v("#")]),v._v(" 9. vue-router hash 模式和 history 模式有什么区别？")]),v._v(" "),e("p",[v._v("区别：")]),v._v(" "),e("ol",[e("li",[v._v('url 展示上，hash 模式有 "#"，history 模式没有')]),v._v(" "),e("li",[v._v("刷新⻚⾯时，hash 模式可以正常加载到 hash 值对应的⻚⾯，⽽ history 没有处理的话，会返回404，⼀般需要后端将所有⻚⾯都配置重定向到⾸⻚路由。")]),v._v(" "),e("li",[v._v("兼容性。hash 可以⽀持低版本浏览器和 IE")])]),v._v(" "),e("h2",{attrs:{id:"_10-vue-router-hash-模式和-history-模式是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-router-hash-模式和-history-模式是如何实现的"}},[v._v("#")]),v._v(" 10. vue-router hash 模式和 history 模式是如何实现的？")]),v._v(" "),e("ul",[e("li",[v._v("hash 模式：")])]),v._v(" "),e("p",[e("code",[v._v("#")]),v._v(" 后⾯ hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新⻚⾯。同时通过监听 hashchange 事件可以知道 hash 发⽣了哪些变化，然后根据 hash 变化来实现更新⻚⾯部分内容的操作。")]),v._v(" "),e("ul",[e("li",[v._v("history 模式：")])]),v._v(" "),e("p",[v._v("history 模式的实现，主要是 HTML5 标准发布的两个 API， "),e("code",[v._v("pushState")]),v._v(" 和 "),e("code",[v._v("replaceState")]),v._v(" ，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新⻚⾯部分内容的操作。")]),v._v(" "),e("h2",{attrs:{id:"_11-vue3-0-相对于-vue2-x-有哪些变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue3-0-相对于-vue2-x-有哪些变化"}},[v._v("#")]),v._v(" 11. vue3.0 相对于 vue2.x 有哪些变化？")]),v._v(" "),e("ul",[e("li",[v._v("监测机制的改变（Object.defineProperty —> Proxy）")]),v._v(" "),e("li",[v._v("模板")]),v._v(" "),e("li",[v._v("对象式的组件声明⽅式 （class）")]),v._v(" "),e("li",[v._v("使⽤ts")]),v._v(" "),e("li",[v._v("其它⽅⾯的更改：⽀持⾃定义渲染器、 ⽀持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件、基于 treeshaking 优化，提供了更多的内置功能")])]),v._v(" "),e("h2",{attrs:{id:"_12-那你能讲一讲mvvm吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-那你能讲一讲mvvm吗"}},[v._v("#")]),v._v(" 12. 那你能讲⼀讲MVVM吗？")]),v._v(" "),e("ul",[e("li",[v._v("MVVM是 "),e("code",[v._v("Model-View-ViewModel")]),v._v(" 缩写，也就是把 "),e("code",[v._v("MVC")]),v._v(" 中的 "),e("code",[v._v("Controller")]),v._v(" 演变成 "),e("code",[v._v("ViewModel")]),v._v(" 。")]),v._v(" "),e("li",[v._v("Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，"),e("strong",[v._v("数据会绑定到viewModel层并⾃动将数据渲染到⻚⾯中，视图变化的时候会通知viewModel层更新数据")]),v._v("。")])]),v._v(" "),e("h2",{attrs:{id:"_13-vue-中组件-data-为什么是-return-一个对象的函数-而不是直接是个对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-中组件-data-为什么是-return-一个对象的函数-而不是直接是个对象"}},[v._v("#")]),v._v(" 13. vue 中组件 data 为什么是 return ⼀个对象的函数，⽽不是直接是个对象？")]),v._v(" "),e("ul",[e("li",[v._v("如果将data定义为对象，这就表示"),e("strong",[v._v("所有的组件实例共⽤了⼀份data数据")]),v._v("，因此，⽆论在哪个组件实例中修改了data,都会影响到所有的组件实例。")]),v._v(" "),e("li",[v._v("组件中的data写成⼀个函数，"),e("strong",[v._v("数据以函数返回值形式定义")]),v._v("，这样每复⽤⼀次组件，就会返回⼀份新的data，类似于给每个组件实例创建⼀个"),e("strong",[v._v("私有的数据空间")]),v._v("，让各个组件实例维护各⾃的数据。⽽单纯的写成对象形式，就使得所有组件实例共⽤了⼀份data，就会造成⼀个变了全都会变的结果。")])]),v._v(" "),e("h2",{attrs:{id:"_14-vue-中的-computed-是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-中的-computed-是如何实现的"}},[v._v("#")]),v._v(" 14. Vue 中的 computed 是如何实现的")]),v._v(" "),e("hr"),v._v(" "),e("p",[e("strong",[v._v("流程总结如下：")])]),v._v(" "),e("ol",[e("li",[e("p",[v._v("当组件初始化的时候， "),e("code",[v._v("computed")]),v._v(" 和 "),e("code",[v._v("data")]),v._v(" 会分别建⽴各⾃的响应系统， "),e("code",[v._v("Observer")]),v._v(" 遍历 "),e("code",[v._v("data")]),v._v("中每个属性设置 "),e("code",[v._v("get/set")]),v._v(" 数据拦截")])]),v._v(" "),e("li",[e("p",[v._v("初始化 "),e("code",[v._v("computed")]),v._v(" 会调⽤ "),e("code",[v._v("initComputed")]),v._v(" 函数")])])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("注册⼀个 "),e("code",[v._v("watcher")]),v._v(" 实例，并在内实例化⼀个 "),e("code",[v._v("Dep")]),v._v(" 消息订阅器⽤作后续收集依赖（⽐如渲染函数的 "),e("code",[v._v("watcher")]),v._v(" 或者其他观察该计算属性变化的 "),e("code",[v._v("watcher")]),v._v(" ）")])]),v._v(" "),e("li",[e("p",[v._v("调⽤计算属性时会触发其 "),e("code",[v._v("Object.defineProperty")]),v._v(" 的 "),e("code",[v._v("get")]),v._v(" 访问器函数")])]),v._v(" "),e("li",[e("p",[v._v("调⽤ "),e("code",[v._v("watcher.depend()")]),v._v(" ⽅法向⾃身的消息订阅器 "),e("code",[v._v("dep")]),v._v(" 的 "),e("code",[v._v("subs")]),v._v(" 中添加其他属性的\n"),e("code",[v._v("watcher")])])]),v._v(" "),e("li",[e("p",[v._v("调⽤ "),e("code",[v._v("watcher")]),v._v(" 的 "),e("code",[v._v("evaluate")]),v._v(" ⽅法（进⽽调⽤ "),e("code",[v._v("watcher")]),v._v(" 的 "),e("code",[v._v("get")]),v._v(" ⽅法）让⾃身成为其他\n"),e("code",[v._v("watcher")]),v._v(" 的消息订阅器的订阅者，⾸先将 "),e("code",[v._v("watcher")]),v._v(" 赋给 "),e("code",[v._v("Dep.target")]),v._v(" ，然后执⾏ "),e("code",[v._v("getter")]),v._v("\n求值函数，当访问求值函数⾥⾯的属性（⽐如来⾃ "),e("code",[v._v("data")]),v._v(" 、 "),e("code",[v._v("props")]),v._v(" 或其他 "),e("code",[v._v("computed")]),v._v(" ）时，\n会同样触发它们的 "),e("code",[v._v("get")]),v._v(" 访问器函数从⽽将该计算属性的 "),e("code",[v._v("watcher")]),v._v(" 添加到求值函数中属性的\n"),e("code",[v._v("watcher")]),v._v(" 的消息订阅器 "),e("code",[v._v("dep")]),v._v(" 中，当这些操作完成，最后关闭 "),e("code",[v._v("Dep.target")]),v._v(" 赋为 "),e("code",[v._v("null")]),v._v(" 并\n返回求值函数结果。")])])]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[v._v("当某个属性发⽣变化，触发 "),e("code",[v._v("set")]),v._v(" 拦截函数，然后调⽤⾃身消息订阅器 "),e("code",[v._v("dep")]),v._v(" 的 "),e("code",[v._v("notify")]),v._v(" ⽅法，遍\n历当前 dep 中保存着所有订阅者 "),e("code",[v._v("wathcer")]),v._v(" 的 "),e("code",[v._v("subs")]),v._v(" 数组，并逐个调⽤ "),e("code",[v._v("watcher")]),v._v(" 的 "),e("code",[v._v("update")]),v._v(" ⽅\n法，完成响应更新。")])]),v._v(" "),e("h2",{attrs:{id:"_15-vue-的响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-vue-的响应式原理"}},[v._v("#")]),v._v(" 15. Vue 的响应式原理")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("如果⾯试被问到这个问题，⼜描述不清楚，可以直接画出 Vue 官⽅⽂档的这个图，对着图来解释效果会更好。\n"),e("img",{attrs:{src:"/images/interview/vue/vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.jpg",alt:"vue的响应式原理"}})]),v._v(" "),e("ul",[e("li",[v._v("Vue 的响应式是通过 "),e("code",[v._v("Object.defineProperty")]),v._v(" 对数据进⾏"),e("strong",[v._v("劫持")]),v._v("，并结合"),e("strong",[v._v("观察者模式")]),v._v("实现。")]),v._v(" "),e("li",[v._v("Vue 利⽤"),e("code",[v._v("Object.defineProperty")]),v._v(" 创建⼀个 "),e("code",[v._v("observe")]),v._v(" 来劫持监听所有的属性，把这些属性全部转为 "),e("code",[v._v("getter")]),v._v("和 "),e("code",[v._v("setter")]),v._v(" 。")]),v._v(" "),e("li",[v._v("Vue 中每个组件实例都会对应⼀个 "),e("code",[v._v("watcher")]),v._v(" 实例，它会在组件渲染的过程中把使⽤过的\n数据属性通过 "),e("code",[v._v("getter")]),v._v(" 收集为依赖。之后当依赖项的 "),e("code",[v._v("setter")]),v._v(" 触发时，会通知 "),e("code",[v._v("watcher")]),v._v(" ，从⽽使它关联的组件重新渲染。")])]),v._v(" "),e("h2",{attrs:{id:"_16-object-defineproperty有哪些缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-object-defineproperty有哪些缺点"}},[v._v("#")]),v._v(" 16. Object.defineProperty有哪些缺点？")]),v._v(" "),e("hr"),v._v(" "),e("ol",[e("li",[e("code",[v._v("Object.defineProperty")]),v._v(" 只能劫持"),e("strong",[v._v("对象的属性")]),v._v("，⽽ "),e("code",[v._v("Proxy")]),v._v(" 是直接"),e("strong",[v._v("代理对象")]),v._v("由于 "),e("code",[v._v("Object.defineProperty")]),v._v(" 只能对属性进⾏劫持，需要遍历对象的每个属性。⽽ Proxy 可以直接代理对象。")]),v._v(" "),e("li",[e("code",[v._v("Object.defineProperty")]),v._v(" 对新增属性需要⼿动进⾏ "),e("code",[v._v("Observe")]),v._v(" ， 由于\n"),e("code",[v._v("Object.defineProperty")]),v._v(" 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新\n增属性再使⽤ "),e("code",[v._v("Object.defineProperty")]),v._v(" 进⾏劫持。 也正是因为这个原因，使⽤ Vue 给 "),e("code",[v._v("data")]),v._v("中的数组或对象新增属性时，需要使⽤ "),e("code",[v._v("vm.$set")]),v._v("才能保证新增的属性也是响应式的。")]),v._v(" "),e("li",[e("code",[v._v("Proxy")]),v._v(" ⽀持"),e("strong",[v._v("13种拦截")]),v._v("操作，这是 "),e("code",[v._v("defineProperty")]),v._v(" 所不具有的。")]),v._v(" "),e("li",[v._v("新标准性能红利Proxy 作为新标准，⻓远来看，JS引擎会继续优化 "),e("code",[v._v("Proxy")]),v._v(" ，但 "),e("code",[v._v("getter")]),v._v(" 和 "),e("code",[v._v("setter")]),v._v(" 基本不会再有针对性优化。")]),v._v(" "),e("li",[e("code",[v._v("Proxy")]),v._v(" 兼容性差 ⽬前并没有⼀个完整⽀持 "),e("code",[v._v("Proxy")]),v._v(" 所有拦截⽅法的Polyfill⽅案")])]),v._v(" "),e("h2",{attrs:{id:"_17-vue2-0中如何检测数组变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-vue2-0中如何检测数组变化"}},[v._v("#")]),v._v(" 17. Vue2.0中如何检测数组变化？")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("Vue 的 "),e("code",[v._v("Observer")]),v._v(" 对数组做了单独的处理，对数组的⽅法进⾏编译，并赋值给数组属性的 "),e("code",[v._v("__proto__")]),v._v("属性上，因为"),e("strong",[v._v("原型链")]),v._v("的机制，找到对应的⽅法就不会继续往上找了。编译⽅法中会对⼀些会增加索引的⽅法（ "),e("code",[v._v("push")]),v._v(" ， "),e("code",[v._v("unshift")]),v._v(" ， "),e("code",[v._v("splice")]),v._v(" ）进⾏⼿动 observe。")]),v._v(" "),e("h2",{attrs:{id:"_18-nexttick是做什么用的-其原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-nexttick是做什么用的-其原理是什么"}},[v._v("#")]),v._v(" 18. nextTick是做什么⽤的，其原理是什么?")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("能回答清楚这道问题的前提，是清楚 EventLoop 过程。")]),v._v(" "),e("ul",[e("li",[v._v("在下次 DOM 更新循环结束后执⾏延迟回调，在修改数据之后⽴即使⽤ nextTick 来获取更新后的DOM。")]),v._v(" "),e("li",[e("code",[v._v("nextTick")]),v._v(" 对于 micro task 的实现，会先检测是否⽀持 "),e("code",[v._v("Promise")]),v._v(" ，不⽀持的话，直接指向 macrotask，⽽ macro task 的实现，优先检测是否⽀持 "),e("code",[v._v("setImmediate")]),v._v(" （⾼版本IE和Etage⽀持），不⽀持的再去检测是否⽀持 MessageChannel，如果仍不⽀持，最终降级为 "),e("code",[v._v("setTimeout")]),v._v(" 0；")]),v._v(" "),e("li",[v._v("默认的情况，会先以 micro task ⽅式执⾏，因为 micro task 可以在⼀次 tick 中全部执⾏完毕，在⼀些有重绘和动画的场景有更好的性能。")]),v._v(" "),e("li",[v._v("但是由于 micro task 优先级较⾼，在某些情况下，可能会在事件冒泡过程中触发，导致⼀些问题，所以有些地⽅会强制使⽤ macro task （如 "),e("code",[v._v("v-on")]),v._v(" ）。")])]),v._v(" "),e("p",[e("strong",[v._v("注意")]),v._v("：之所以将 "),e("code",[v._v("nextTick")]),v._v(" 的回调函数放⼊到数组中⼀次性执⾏，⽽不是直接在 "),e("code",[v._v("nextTick")]),v._v(" 中执⾏回调函数，是为了保证在同⼀个tick内多次执⾏了 "),e("code",[v._v("nextTcik")]),v._v(" ，不会开启多个异步任务，⽽是把这些异步任务都压成⼀个同步任务，在下⼀个tick内执⾏完毕。")]),v._v(" "),e("h2",{attrs:{id:"_19-vue-的模板编译原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue-的模板编译原理"}},[v._v("#")]),v._v(" 19. Vue 的模板编译原理")]),v._v(" "),e("hr"),v._v(" "),e("p",[v._v("vue模板的编译过程分为3个阶段：")]),v._v(" "),e("ul",[e("li",[v._v("第⼀步：解析")])]),v._v(" "),e("p",[v._v("将模板字符串解析⽣成 AST，⽣成的AST 元素节点总共有 3 种类型，1 为普通元素， 2 为表达式，3为纯⽂本。")]),v._v(" "),e("ul",[e("li",[v._v("第⼆步：优化语法树")])]),v._v(" "),e("p",[v._v("Vue 模板中并不是所有数据都是响应式的，有很多数据是⾸次渲染后就永远不会变化的，那么这部分数据⽣成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的⽐对。")]),v._v(" "),e("p",[v._v("此阶段会深度遍历⽣成的 AST 树，检测它的每⼀颗⼦树是不是静态节点，如果是静态节点则它们⽣成DOM 永远不需要改变，这对运⾏时对模板的更新起到极⼤的优化作⽤。")]),v._v(" "),e("ol",[e("li",[v._v("⽣成代码")])]),v._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" code "),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[v._v("generate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("ast"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" options"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br")])]),e("p",[v._v("通过 generate ⽅法，将ast⽣成 render 函数。")]),v._v(" "),e("h2",{attrs:{id:"_20-你知道vue3-x响应式数据原理吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-你知道vue3-x响应式数据原理吗"}},[v._v("#")]),v._v(" 20. 你知道Vue3.x响应式数据原理吗？")]),v._v(" "),e("p",[v._v("Vue3.x改⽤ "),e("code",[v._v("Proxy")]),v._v(" 替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截⽅法。并且作为新标准将受到浏览器⼚商重点持续的性能优化。")]),v._v(" "),e("blockquote",[e("p",[v._v("Proxy只会代理对象的第⼀层，那么Vue3⼜是怎样处理这个问题的呢？")])]),v._v(" "),e("p",[v._v("判断当前Reflect.get的返回值是否为Object，如果是则再通过 reactive ⽅法做代理， 这样就实现了深度观测。")]),v._v(" "),e("blockquote",[e("p",[v._v("监测数组的时候可能触发多次get/set，那么如何防⽌触发多次呢？")])]),v._v(" "),e("p",[v._v("我们可以判断key是否为当前被代理对象target⾃身属性，也可以判断旧值与新值是否相等，只有满⾜以上两个条件之⼀时，才有可能执⾏trigger。")]),v._v(" "),e("h2",{attrs:{id:"_21-你都做过哪些vue的性能优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-你都做过哪些vue的性能优化"}},[v._v("#")]),v._v(" 21. 你都做过哪些Vue的性能优化？")]),v._v(" "),e("p",[e("strong",[v._v("编码阶段")])]),v._v(" "),e("ul",[e("li",[v._v("尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher")]),v._v(" "),e("li",[v._v("v-if和v-for不能连⽤")]),v._v(" "),e("li",[v._v("如果需要使⽤v-for给每项元素绑定事件时使⽤事件代理")]),v._v(" "),e("li",[v._v("SPA ⻚⾯采⽤keep-alive缓存组件")]),v._v(" "),e("li",[v._v("在更多的情况下，使⽤v-if替代v-show")]),v._v(" "),e("li",[v._v("key保证唯⼀")]),v._v(" "),e("li",[v._v("使⽤路由懒加载、异步组件")]),v._v(" "),e("li",[v._v("防抖、节流")]),v._v(" "),e("li",[v._v("第三⽅模块按需导⼊")]),v._v(" "),e("li",[v._v("⻓列表滚动到可视区域动态加载")]),v._v(" "),e("li",[v._v("图⽚懒加载")])]),v._v(" "),e("p",[e("strong",[v._v("SEO优化")])]),v._v(" "),e("ul",[e("li",[v._v("预渲染")]),v._v(" "),e("li",[v._v("服务端渲染SSR")])]),v._v(" "),e("p",[e("strong",[v._v("打包优化")])]),v._v(" "),e("ul",[e("li",[v._v("压缩代码")]),v._v(" "),e("li",[v._v("Tree Shaking/Scope Hoisting")]),v._v(" "),e("li",[v._v("使⽤cdn加载第三⽅模块")]),v._v(" "),e("li",[v._v("多线程打包happypack")]),v._v(" "),e("li",[v._v("splitChunks抽离公共⽂件")]),v._v(" "),e("li",[v._v("sourceMap优化")])]),v._v(" "),e("p",[e("strong",[v._v("⽤户体验")])]),v._v(" "),e("ul",[e("li",[v._v("骨架屏")]),v._v(" "),e("li",[v._v("PWA")])]),v._v(" "),e("p",[v._v("还可以使⽤缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。")])])}),[],!1,null,null,null);_.default=o.exports}}]);